<!DOCTYPE html>
<html class="theme-sleek astro-RDWXBD3Z" lang="en">
  <head>
    <!-- Global Metadata -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="Blogster">
    <meta name="theme-color" content="#ffffff">

<!-- 
  This is an example. 
  Use https://realfavicongenerator.net to generate the icons and manifest. 
-->
<link href="/favicon.ico" rel="shortcut icon">

    <!-- Primary Meta Tags --><title>정말 리액트에서 useMemo를 사용해야 할까요? 알아봅시다. (번역)</title>
<meta name="title" content="정말 리액트에서 useMemo를 사용해야 할까요? 알아봅시다. (번역)">
<meta name="description" content="description">


<!-- Open Graph / Facebook -->
<meta property="og:title" content="정말 리액트에서 useMemo를 사용해야 할까요? 알아봅시다. (번역)">
<meta property="og:description" content="description">
<meta property="og:type" content="article">
<meta property="og:url" content="http://localhost:3000/blog/JavaScript/should-you-really-use-usememo">
<meta property="article:author" content="연주안">
<meta property="article:published_time" content="2023-03-19T00:00:00.000Z">





<!-- Twitter -->
<meta property="twitter:title" content="정말 리액트에서 useMemo를 사용해야 할까요? 알아봅시다. (번역)">
<meta property="twitter:description" content="description">


<meta property="twitter:card" content="summary_large_image">


<!-- {twitter.url && <meta property="twitter:url" content={twitter.url} />} -->

    <!-- 
    We don't want to use <link /> to load fonts from Google CDN 
    but if you want to switch font this is the easiest way 
    to check how your page will look with the new font.
--><!-- 
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
        href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,400;0,600;0,700;0,800;1,400;1,700&display=block"
        rel="stylesheet"
    />
    <link
        href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,400;0,700;0,800;1,400&display=swap"
        rel="stylesheet"
    />
--><link rel="preload" href="/fonts/open-sans-v34-latin-regular.woff2" as="font" type="font/woff2" crossorigin="crossorigin"><link rel="preload" href="/fonts/open-sans-v34-latin-700.woff2" as="font" type="font/woff2" crossorigin="crossorigin"><link rel="preload" href="/fonts/open-sans-v34-latin-800.woff2" as="font" type="font/woff2" crossorigin="crossorigin"><link rel="preload" href="/fonts/open-sans-v34-latin-italic.woff2" as="font" type="font/woff2" crossorigin="crossorigin"><style>
    /* open-sans-regular - latin */
    @font-face {
      font-family: "Open Sans";
      font-style: normal;
      font-weight: 400;
      font-display: fallback;
      src: local(""),
        url("/fonts/open-sans-v34-latin-regular.woff2") format("woff2"),
        /* Chrome 26+, Opera 23+, Firefox 39+ */
          url("/fonts/open-sans-v34-latin-regular.woff") format("woff"); /* Chrome 6+, Firefox 3.6+, IE 9+, Safari 5.1+ */
    }
    /* open-sans-700 - latin */
    @font-face {
      font-family: "Open Sans";
      font-style: normal;
      font-weight: 700;
      font-display: fallback;
      src: local(""),
        url("/fonts/open-sans-v34-latin-700.woff2") format("woff2"),
        /* Chrome 26+, Opera 23+, Firefox 39+ */
          url("/fonts/open-sans-v34-latin-700.woff") format("woff"); /* Chrome 6+, Firefox 3.6+, IE 9+, Safari 5.1+ */
    }
    /* open-sans-800 - latin */
    @font-face {
      font-family: "Open Sans";
      font-style: normal;
      font-weight: 800;
      font-display: fallback;
      src: local(""),
        url("/fonts/open-sans-v34-latin-800.woff2") format("woff2"),
        /* Chrome 26+, Opera 23+, Firefox 39+ */
          url("/fonts/open-sans-v34-latin-800.woff") format("woff"); /* Chrome 6+, Firefox 3.6+, IE 9+, Safari 5.1+ */
    }
    /* open-sans-italic - latin */
    @font-face {
      font-family: "Open Sans";
      font-style: italic;
      font-weight: 400;
      font-display: fallback;
      src: local(""),
        url("/fonts/open-sans-v34-latin-italic.woff2") format("woff2"),
        /* Chrome 26+, Opera 23+, Firefox 39+ */
          url("/fonts/open-sans-v34-latin-italic.woff") format("woff"); /* Chrome 6+, Firefox 3.6+, IE 9+, Safari 5.1+ */
    }
  </style>

    <script>
  // figure out user's preferred theme and set it as html class for tailwind before paint
  (function () {
    if (typeof window !== "undefined") {
      const isSystemColorSchemeDark = window.matchMedia(
        "(prefers-color-scheme: dark)"
      ).matches;
      const storageTheme = sessionStorage.getItem("theme");
      if (!storageTheme && isSystemColorSchemeDark) {
        document.documentElement.classList.add("dark");
        document.head.children.namedItem("theme-color").content = "#0e141b";
      } else if (storageTheme === "dark") {
        document.documentElement.classList.add("dark");
        document.head.children.namedItem("theme-color").content = "#0e141b";
      } else {
        // we already server render light theme
        document.head.children.namedItem("theme-color").content = "#ffffff";
      }
    }
  })();
</script>

    <link href="/fontawesome/css/fontawesome.bareminimum.css" rel="stylesheet"><link href="/fontawesome/css/brands.bareminimum.css" rel="stylesheet"><link href="/fontawesome/css/solid.min.css" rel="stylesheet">

  <link rel="stylesheet" href="/assets/_...slug_.eb89f7da.css" />
<link rel="stylesheet" href="/assets/_...slug_.43380762.css" /><script type="module" src="/hoisted.fee86805.js"></script></head>

  <body class="min-h-screen max-w-3xl mx-auto px-6 sm:px-8 astro-RDWXBD3Z">
    <header class="astro-ZCCACUUV">
  <a class="unset absolute z-10 left-[50%] -top-[100rem] translate-x-[-50%] bg-white text-black px-8 py-2 focus:top-[initial] astro-ZCCACUUV" href="#main">
    Skip to content
  </a>
  <nav class="astro-ZCCACUUV">
    <section class="text-text-bold astro-ZCCACUUV">
      <ul class="unset flex gap-4 [&>li]:p-0 astro-ZCCACUUV">
        <li class="astro-ZCCACUUV"><!-- DO NOT FORMAT. IT ADDS AN EXTRA SPACE ON RENDERED CONTENT. --><a href="/" class="astro-ZCCACUUV unset animated-link">Home</a></li>
        <li class="astro-ZCCACUUV"><!-- DO NOT FORMAT. IT ADDS AN EXTRA SPACE ON RENDERED CONTENT. --><a href="/blog" class="astro-ZCCACUUV show unset animated-link">Blog</a></li>
      </ul>
    </section>
  </nav>
  <div class="max-[375px]:hidden justify-self-end py-2 flex items-center content-center text-text-bold astro-ZCCACUUV">
    <a class="unset text-xl ml-4 hover:text-text-link astro-ZCCACUUV" href="https://github.com/yeonjuan" target="_blank">
      <i class="fa-brands fa-github astro-ZCCACUUV" aria-hidden="true" title="Blogster on GitHub"></i>
      <span class="fa-sr-only astro-ZCCACUUV">YeonJuAn GitHub</span>
    </a>
  </div>
  <mode-toggle class="flex astro-2DKTDEXU">
  <button class="justify-self-end bg-neutral-200 dark:bg-neutral-700 ml-4 inline-flex h-6 w-11 items-center rounded-full astro-2DKTDEXU" id="mode-toggle" role="switch" type="button" tabindex="0" aria-checked="false" data-headlessui-state=""><span class="sr-only astro-2DKTDEXU">Toggle dark mode</span><span id="mode-circle" class="light inline-block h-4 w-4 rounded-full bg-gradient-to-tr invisible astro-2DKTDEXU"><span class="absolute top-0 right-0 w-[10px] h-[10px] rounded-full bg-gray-700 scale-[0] astro-2DKTDEXU"></span>
  </span>
</button>
</mode-toggle>




</header>

    <main id="main" class="astro-RDWXBD3Z">
      <section class="blog-post prose max-w-none prose-sleek astro-RDWXBD3Z">
        <time class="block mb-[2em] text-text-muted astro-RDWXBD3Z">Mar 19, 2023</time>
        <article><h1 id="usememo-." class="group flex -ml-[1rem]"><span class="not-prose w-[1rem] -mt-[0.125rem]">
        <a aria-label="link to this heading" aria-describedby="정말 리액트에서 useMemo를 사용해야 할까요? 알아봅시다." href="#usememo-." class="unset align-middle text-[14px] text-text-link opacity-0 group-hover:opacity-100 group-focus:opacity-100 focus:opacity-100 group-active:opacity-100 active:opacity-100">
            <i class="fa-solid fa-hashtag"></i>
        </a>
    </span><span>정말 리액트에서 useMemo를 사용해야 할까요? 알아봅시다.</span></h1><blockquote><paragraph>원문: https://medium.com/swlh/should-you-use-usememo-in-react-a-benchmarked-analysis-159faf6609b7</paragraph></blockquote><paragraph>최근 몇몇 개발자가 리액트에서 <em>useMemo</em>를 언제 사용해야 하느냐는 질문을 했습니다. 좋은 질문입니다. 이 글에서는 과학적인 접근법으로, 가설을 정의한 다음, 리액트의 실제 벤치마크로 이를 테스트해 보겠습니다.</paragraph><paragraph>useMemo가 성능에 미치는 영향이 궁금하다면 계속 읽어보세요.</paragraph><h2 id="usememo" class="group flex -ml-[1rem]"><span class="not-prose w-[1rem] -mt-[0.125rem]">
        <a aria-label="link to this heading" aria-describedby="useMemo 란?" href="#usememo" class="unset align-middle text-[14px] text-text-link opacity-0 group-hover:opacity-100 group-focus:opacity-100 focus:opacity-100 group-active:opacity-100 active:opacity-100">
            <i class="fa-solid fa-hashtag"></i>
        </a>
    </span><span>useMemo 란?</span></h2><paragraph><a href="https://reactjs.org/docs/hooks-reference.html#usememo">useMemo</a>는 리액트에서 제공하는 훅 중에 하나입니다. 이 훅을 사용하면 개발자가 종속성 목록에 따라 변수의 값을 캐시 할 수 있습니다. 종속성 목록의 변수가 변경되면 리액트는 이 데이터에 대한 처리를 다시 실행하고 캐시 합니다. 종속성 목록의 변숫값이 이전에 캐시된 적이 있으면 리액트는 캐시에서 값을 가져옵니다.</paragraph><paragraph>이는 주로 컴포넌트 리렌더링에 영향을 미칩니다. 컴포넌트가 다시 렌더링 되면 배열을 반복하거나 데이터를 처리할 필요 없이 캐시에서 값을 가져옵니다.</paragraph><h2 id="usememo" class="group flex -ml-[1rem]"><span class="not-prose w-[1rem] -mt-[0.125rem]">
        <a aria-label="link to this heading" aria-describedby="리액트에서는 useMemo에 대해 뭐라고 하나요?" href="#usememo" class="unset align-middle text-[14px] text-text-link opacity-0 group-hover:opacity-100 group-focus:opacity-100 focus:opacity-100 group-active:opacity-100 active:opacity-100">
            <i class="fa-solid fa-hashtag"></i>
        </a>
    </span><span>리액트에서는 useMemo에 대해 뭐라고 하나요?</span></h2><paragraph><a href="https://reactjs.org/docs/hooks-reference.html#usememo">useMemo에 대한 리액트 문서</a>를 보면 언제 사용해야 하는지에 대한 언급이 없습니다. 단순히 기능과 사용 방법에 대해 언급하고 있습니다.</paragraph><blockquote><paragraph>성능 최적화를 위해 <code>useMemo</code>를 사용할 수 있습니다.</paragraph></blockquote><paragraph>여기서 궁금한 점은 어느 시점부터 useMemo가 흥미롭냐는 것입니다. useMemo를 사용할 때 성능 이점을 얻으려면 데이터가 얼마나 복잡하거나 커야 할까요? 개발자들은 실제로 언제 useMemo를 사용해야 할까요?</paragraph><h2 id="" class="group flex -ml-[1rem]"><span class="not-prose w-[1rem] -mt-[0.125rem]">
        <a aria-label="link to this heading" aria-describedby="가설" href="#" class="unset align-middle text-[14px] text-text-link opacity-0 group-hover:opacity-100 group-focus:opacity-100 focus:opacity-100 group-active:opacity-100 active:opacity-100">
            <i class="fa-solid fa-hashtag"></i>
        </a>
    </span><span>가설</span></h2><paragraph>실험을 시작하기 전에 가설을 정의해 보겠습니다.</paragraph><paragraph>먼저 <strong>처리하고자 하는 객체와 처리의 복잡도</strong>를 n으로 정의합니다. n = 100 이면, 캐시된 변수의 최종값을 얻기 위해 100개의 항목 배열을 반복해야 합니다.</paragraph><paragraph>그다음 두 액션을 분리해야 합니다. 첫 번째 액션은 컴포넌트의 <strong>초기 렌더링</strong>입니다. 이 경우 변수가 useMemo를 사용하는지에 관계없이 초깃값을 계산해야 합니다. 첫 번째 렌더링이 완료되면 useMemo를 사용한 <strong>후속 리렌더링</strong>(측정해야 하는 두 번째 작업)에서는 캐시에서 값을 찾을 수 있으며, 이 경우 캐시 하지 않은 버전 대비 성능 이점을 볼 수 있습니다.</paragraph><paragraph>모든 경우에서, 초기 렌더링 시에 캐시를 설정하고 값을 저장하기 위해 약 5-10%의 오버헤드가 예상됩니다. n &lt; 1000 미만일 때 useMemo로 인한 성능 저하를 예상합니다. n &gt; 1000인 경우, useMemo를 사용하여 리렌더링에서 유사하거나 더 나은 성능을 기대할 수 있지만 추가 캐싱 알고리즘으로 인해 초기 렌더링은 여전히 약간 느려질 수 있습니다. 당신의 가설은 무엇입니까?</paragraph><h2 id="" class="group flex -ml-[1rem]"><span class="not-prose w-[1rem] -mt-[0.125rem]">
        <a aria-label="link to this heading" aria-describedby="벤치마크 셋업" href="#" class="unset align-middle text-[14px] text-text-link opacity-0 group-hover:opacity-100 group-focus:opacity-100 focus:opacity-100 group-active:opacity-100 active:opacity-100">
            <i class="fa-solid fa-hashtag"></i>
        </a>
    </span><span>벤치마크 셋업</span></h2><paragraph>다음과 같이 작은 리액트 컴포넌트를 만들었습니다. 설명한 대로 복잡성 n을 가진 객체를 생성하며 복잡성은 <em>level</em> 프로퍼티로 정의됩니다.</paragraph><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">BenchmarkNormal</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>level<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> complexObject <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">values</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> level<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        complexObject<span class="token punctuation">.</span>values<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token string">'mytest'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">Benchmark level: </span><span class="token punctuation">{</span>level<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> BenchmarkNormal<span class="token punctuation">;</span>
</code></pre>

<paragraph>이는 일반적인 벤치마크 컴포넌트이며 <code>useMemo</code>를 사용한 BenchmarkMemo 컴포넌트도 만들 것입니다.</paragraph><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span>useMemo<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">BenchmarkMemo</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>level<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> complexObject <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">{</span>
            <span class="token literal-property property">values</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> level<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            result<span class="token punctuation">.</span>values<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'mytest'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>level<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">Benchmark with memo level: </span><span class="token punctuation">{</span>level<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> BenchmarkMemo<span class="token punctuation">;</span>
</code></pre>

<paragraph>그런 다음 버튼을 누를 때 컴포넌트가 표시되도록 App.js에 설정합니다. 또한 리액트의 <code>&lt;Profiler&gt;</code>을 사용해 렌더링 시간을 제공합니다.</paragraph><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>showBenchmarkNormal<span class="token punctuation">,</span> setShowBenchmarkNormal<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 이 컴포넌트를 렌더링 하는 횟수를 지정하며</span>
  <span class="token comment">// 그리고 이런 모든 렌더링에 대한 평균 렌더링 시간을 계산합니다.</span>
  <span class="token keyword">const</span> timesToRender <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">;</span>
  <span class="token comment">// profiler 콜백</span>
  <span class="token keyword">const</span> <span class="token function-variable function">renderProfiler</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">type</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
      <span class="token comment">// 렌더링 시간을 배열로 유지합니다.</span>
      <span class="token comment">// 나중에 평균 시간을 계산합니다.</span>
      <span class="token comment">// 렌더링 시간인 args[3]을 저장합니다.</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">// 컴포넌트를 렌더링합니다.</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token plain-text">
      </span><span class="token punctuation">{</span>showBenchmarkNormal <span class="token operator">&amp;&amp;</span>
        <span class="token punctuation">[</span><span class="token operator">...</span><span class="token function">Array</span><span class="token punctuation">(</span>timesToRender<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">index</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span> <span class="token punctuation">(</span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Profiler</span></span>
              <span class="token attr-name">id</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">normal-</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>index<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">}</span></span>
              <span class="token attr-name">onRender</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token function">renderProfiler</span><span class="token punctuation">(</span><span class="token string">"normal"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span>
            <span class="token punctuation">></span></span><span class="token plain-text">
              </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">BenchmarkNormal</span></span> <span class="token attr-name">level</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">
            </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Profiler</span></span><span class="token punctuation">></span></span>
          <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>

<paragraph>보시다시피 컴포넌트를 10,000번 렌더링하고 이에 대한 평균 렌더링 시간을 가져옵니다. 그리고 useMemo를 재계산할 필요 없이 필요할 때마다 컴포넌트를 다시 렌더링할 수 있는 메커니즘이 필요합니다. 그러려면 useMemo의 종속성 목록에 있는 어떤 값도 수정하지 않아야 합니다.</paragraph><pre class="language-jsx"><code class="language-jsx"><span class="token comment">// state에 간단한 카운터를 추가합니다.</span>
<span class="token comment">// 이는 리렌더링을 발생하기 위해 사용됩니다.</span>
<span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">triggerReRender</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 추가적인 prop를 가지도록 벤치마크 컴포넌트를 업데이트 합니다.</span>
<span class="token comment">// 강제로 리렌더링 됩니다.</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">BenchmarkNormal</span></span> <span class="token attr-name">level</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span></span> <span class="token attr-name">count</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>count<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><span class="token punctuation">;</span>
</code></pre>

<paragraph>결과를 깔끔하게 유지하기 위해서, 테스트를 시작하기 전에 항상 브라우저 새 웹페이지로 시작(리렌더링 제외)하여 페이지에 남아 결과에 영향을 줄 수 있는 캐시를 모두 정리합니다.</paragraph><h2 id="" class="group flex -ml-[1rem]"><span class="not-prose w-[1rem] -mt-[0.125rem]">
        <a aria-label="link to this heading" aria-describedby="결과" href="#" class="unset align-middle text-[14px] text-text-link opacity-0 group-hover:opacity-100 group-focus:opacity-100 focus:opacity-100 group-active:opacity-100 active:opacity-100">
            <i class="fa-solid fa-hashtag"></i>
        </a>
    </span><span>결과</span></h2><h3 id="n-1" class="group flex -ml-[1rem]"><span class="not-prose w-[1rem] -mt-[0.125rem]">
        <a aria-label="link to this heading" aria-describedby="복잡도 n = 1 결과" href="#n-1" class="unset align-middle text-[14px] text-text-link opacity-0 group-hover:opacity-100 group-focus:opacity-100 focus:opacity-100 group-active:opacity-100 active:opacity-100">
            <i class="fa-solid fa-hashtag"></i>
        </a>
    </span><span>복잡도 n = 1 결과</span></h3><paragraph><image alt="" src="/public/images/blog/use-memo-table-n-1.webp"></image></paragraph><paragraph><image alt="" src="/public/images/blog/use-memo-graph-n-1.webp"></image></paragraph><paragraph>복잡도는 왼쪽 열에 표시되며 첫 번째 테스트는 초기 렌더링, 두 번째 테스트는 첫 번째 리 렌더링, 마지막 테스트는 두 번째 리렌더링 입니다. 두 번째 열은 useMemo를 사용하지 않은 일반 벤치마크 결과입니다. 마지막 열은 useMemo를 사용한 벤치마크 결과입니다. 이 값들은 벤치마크 컴포넌트의 10,000 번 렌더링의 평균 렌더링 시간입니다.</paragraph><paragraph>useMemo를 사용할 때 초기 렌더링은 19% 느려지며 예상치인 5-10% 보다 훨씬 높습니다. 후속 렌더링은 useMemo 캐시를 통과하는 데 든 오버헤드가 실제 값을 재계산하는 것보다 더 비용이 들기 때문에 여전히 느립니다.</paragraph><paragraph>결론적으로 복잡성이 n=1일 경우 오버헤드가 항상 성능보다 크기 때문에 useMemo를 사용하지 않는 것이 항상 빠릅니다.</paragraph><h3 id="n-100" class="group flex -ml-[1rem]"><span class="not-prose w-[1rem] -mt-[0.125rem]">
        <a aria-label="link to this heading" aria-describedby="복잡도 n = 100 결과" href="#n-100" class="unset align-middle text-[14px] text-text-link opacity-0 group-hover:opacity-100 group-focus:opacity-100 focus:opacity-100 group-active:opacity-100 active:opacity-100">
            <i class="fa-solid fa-hashtag"></i>
        </a>
    </span><span>복잡도 n = 100 결과</span></h3><paragraph><image alt="" src="/public/images/blog/use-memo-table-n-100.webp"></image></paragraph><paragraph><image alt="" src="/public/images/blog/use-memo-graph-n-100.webp"></image></paragraph><paragraph>복잡도가 100이면, useMemo를 사용한 초기 렌더링은 62% 느려지는데 이는 상당한 크기입니다. 후속 렌더링은 평균적으로 약간 빠르거나 유사한 것으로 보입니다.</paragraph><paragraph>결론적으로, 100의 복잡도에서, 초기 렌더링은 상당히 느리지만, 후속 리렌더링은 거의 유사하고 기껏해야 조금 더 빠른 정도입니다. 이 시점에서, useMemo가 아직 흥미로워 보이지는 않습니다.</paragraph><h3 id="n-1000" class="group flex -ml-[1rem]"><span class="not-prose w-[1rem] -mt-[0.125rem]">
        <a aria-label="link to this heading" aria-describedby="복잡도 n = 1000 결과" href="#n-1000" class="unset align-middle text-[14px] text-text-link opacity-0 group-hover:opacity-100 group-focus:opacity-100 focus:opacity-100 group-active:opacity-100 active:opacity-100">
            <i class="fa-solid fa-hashtag"></i>
        </a>
    </span><span>복잡도 n = 1000 결과</span></h3><paragraph><image alt="" src="/public/images/blog/use-memo-table-n-1000.webp"></image></paragraph><paragraph><image alt="" src="/public/images/blog/use-memo-graph-n-1000.webp"></image></paragraph><paragraph>복잡도가 1000 이면 useMemo를 사용한 초기 렌더링이 183% 느려지는 것을 볼 수 있습니다. 아마도 useMemo 캐시가 값을 저장하기 위해 더 열심히 일하고 있을 것입니다. 후속 렌더링은 약 37% 더 빠릅니다!</paragraph><paragraph>이 시점에서, 리렌더링 하는 동안 약간의 성능 향상을 볼 수 있지만 공짜는 아닙니다. 초기 렌더링은 183%의 시간 손실로 훨씬 느려집니다.</paragraph><paragraph><strong>결론적으로</strong>, 복잡도가 1000인 경우 초기 렌더링 동안 더 큰 성능 손실(183%)을 볼 수 있지만 이후 렌더링은 약 37% 더 빠릅니다.</paragraph><paragraph>이것이 이미 흥미로운지 아닌지는 사용 사례에 따라 크게 달라집니다. 초기 렌더링 중에 183%의 성능 손실은 납득하기 어렵지만 컴포넌트에서 리렌더링이 많은 경우에는 정당화할 수 있습니다.</paragraph><h3 id="n-5000" class="group flex -ml-[1rem]"><span class="not-prose w-[1rem] -mt-[0.125rem]">
        <a aria-label="link to this heading" aria-describedby="복잡도 n = 5000 결과" href="#n-5000" class="unset align-middle text-[14px] text-text-link opacity-0 group-hover:opacity-100 group-focus:opacity-100 focus:opacity-100 group-active:opacity-100 active:opacity-100">
            <i class="fa-solid fa-hashtag"></i>
        </a>
    </span><span>복잡도 n = 5000 결과</span></h3><paragraph><image alt="" src="/public/images/blog/use-memo-table-n-5000.webp"></image></paragraph><paragraph><image alt="" src="/public/images/blog/use-memo-graph-n-5000.webp"></image></paragraph><paragraph>복잡도가 5000인 경우 useMemo를 사용하면 초기 렌더링 속도가 545% 느려집니다. 데이터 처리가 복잡할수록 초기 렌더링은 useMemo가 없는 것에 비해 느려집니다.</paragraph><paragraph>후속 렌더링을 보면 흥미롭습니다. useMemo를 사용한 경우 후속 렌더링마다 성능이 437%에서 609%까지 향상합니다.</paragraph><paragraph><strong>결론적으로</strong> 초기 렌더링 비용은 useMemo를 사용하면 훨씬 더 비싸지만, 후속 리렌더링에서는 훨씬 더 큰 성능 향상을 보입니다. 여러분의 애플리케이션이 복잡도 &gt; 5000 이상인 데이터/처리를 가지고 있고 어느 정도 리렌더링이 발생하는 경우 useMemo를 사용하는 것의 이점을 볼 수 있습니다.</paragraph><h2 id="" class="group flex -ml-[1rem]"><span class="not-prose w-[1rem] -mt-[0.125rem]">
        <a aria-label="link to this heading" aria-describedby="결과에 대한 참고 사항" href="#" class="unset align-middle text-[14px] text-text-link opacity-0 group-hover:opacity-100 group-focus:opacity-100 focus:opacity-100 group-active:opacity-100 active:opacity-100">
            <i class="fa-solid fa-hashtag"></i>
        </a>
    </span><span>결과에 대한 참고 사항</span></h2><paragraph>친절한 독자 커뮤니티가 초기 렌더링이 훨씬 느려질 수 있는 이유에 대해 프로덕션 모드 실행과 같은 몇 가지 이유를 지적했습니다. 우리는 모든 실험을 다시 했고 결과가 비슷하다는 것을 알게 되었습니다. 비율은 비슷하지만 실제 값은 더 낮을 수 있습니다. 모든 결론이 동일하게 적용됩니다.</paragraph><h2 id="" class="group flex -ml-[1rem]"><span class="not-prose w-[1rem] -mt-[0.125rem]">
        <a aria-label="link to this heading" aria-describedby="결론" href="#" class="unset align-middle text-[14px] text-text-link opacity-0 group-hover:opacity-100 group-focus:opacity-100 focus:opacity-100 group-active:opacity-100 active:opacity-100">
            <i class="fa-solid fa-hashtag"></i>
        </a>
    </span><span>결론</span></h2><paragraph><image alt="" src="/public/images/blog/use-memo-conclusion.webp"></image></paragraph><paragraph>애플리케이션이 배열에 값을 n번 반복하여 추가하는 복잡도 n의 값을 가진 컴포넌트를 사용한 결과입니다. <strong>결과는 데이터의 양과 데이터를 어떻게 처리하는지에 따라 달라질 수 있다는 점에 유의하세요.</strong> 하지만 데이터의 크기에 따른 성능 차이를 대략 파악할 수 있습니다</paragraph><paragraph>사용 사례에 따라 크게 달라지겠지만, 복잡도가 100 미만인 경우 useMemo는 별로 흥미로워 보이지 않습니다. 초기 성능 손실은 약 5~10% 정도일 것으로 예상했지만, 데이터/처리 복잡성에 따라 크게 달라지며 심지어 예상보다 100배나 많은 500%의 성능 손실이 발생할 수도 있다는 사실을 발견했습니다. 결과가 나온 후에도 테스트를 몇 번 다시 실행했으며, 이후 결과는 일관되었고 처음 기록했던 결과와 유사했습니다.</paragraph><h2 id="" class="group flex -ml-[1rem]"><span class="not-prose w-[1rem] -mt-[0.125rem]">
        <a aria-label="link to this heading" aria-describedby="핵심" href="#" class="unset align-middle text-[14px] text-text-link opacity-0 group-hover:opacity-100 group-focus:opacity-100 focus:opacity-100 group-active:opacity-100 active:opacity-100">
            <i class="fa-solid fa-hashtag"></i>
        </a>
    </span><span>핵심</span></h2><paragraph>useMemo는 변수의 동일한 객체 참조를 유지해서 <strong>불필요한 리렌더링을 피하는 데</strong> 유용하다는 것은 모두들 동의할 것입니다.</paragraph><paragraph>useMemo를 사용해 실제 계산을 캐시하는 경우에는, 주요 목표가 하위 컴포넌트에서 리렌더링을 피하는 것이 아닙니다:</paragraph><ul><li>useMemo는 처리량이 많을 때 사용해야 합니다.</li><li>추가 처리를 피하려고 useMemo를 사용하는 것이 흥미로워지는 임곗값은 애플리케이션에 따라 크게 달라집니다.</li><li>처리량이 매우 적은 경우 useMemo를 사용하면 추가 오버헤드가 발생할 수 있습니다.</li></ul><paragraph>언제 useMemo를 사용하시나요? 이번 조사 결과로 언제 사용해야 할지에 대한 생각이 바뀌셨나요? 댓글로 알려주세요!</paragraph></article>
      </section>
    </main>
    <footer class="text-sm leading-[1.75] mt-4 astro-IKVAUYX3">
  <div class="astro-IKVAUYX3">
    This blog is built with
    <a class="unset gradient-link tracking-wider font-bold bg-clip-text text-transparent bg-gradient-to-r from-[#f57111] to-[#f79605] hover:after:bg-gradient-to-r hover:after:from-[#f57111] hover:after:to-[#f79605] astro-IKVAUYX3" href="https://github.com/flexdinesh/blogster" target="_blank">
      Blogster</a>
  </div>
</footer>


    
  </body>
</html>