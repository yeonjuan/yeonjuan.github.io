<!DOCTYPE html>
<html class="theme-sleek astro-RDWXBD3Z" lang="en">
  <head>
    <!-- Global Metadata -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="Blogster">
    <meta name="theme-color" content="#ffffff">

<!-- 
  This is an example. 
  Use https://realfavicongenerator.net to generate the icons and manifest. 
-->
<link href="/favicon.ico" rel="shortcut icon">

    <!-- Primary Meta Tags --><title>자바스크립트 에코시스템의 속도 향상 - 배럴(Barrel) 파일의 대실패 (번역)</title>
<meta name="title" content="자바스크립트 에코시스템의 속도 향상 - 배럴(Barrel) 파일의 대실패 (번역)">
<meta name="description" content="description">


<!-- Open Graph / Facebook -->
<meta property="og:title" content="자바스크립트 에코시스템의 속도 향상 - 배럴(Barrel) 파일의 대실패 (번역)">
<meta property="og:description" content="description">
<meta property="og:type" content="article">
<meta property="og:url" content="http://localhost:3000/blog/JavaScript/speeding-up-the-javascript-ecosystem-the-barrel-file-debacle">
<meta property="article:author" content="연주안">
<meta property="article:published_time" content="2023-10-29T00:00:00.000Z">





<!-- Twitter -->
<meta property="twitter:title" content="자바스크립트 에코시스템의 속도 향상 - 배럴(Barrel) 파일의 대실패 (번역)">
<meta property="twitter:description" content="description">


<meta property="twitter:card" content="summary_large_image">


<!-- {twitter.url && <meta property="twitter:url" content={twitter.url} />} -->

    <!-- 
    We don't want to use <link /> to load fonts from Google CDN 
    but if you want to switch font this is the easiest way 
    to check how your page will look with the new font.
--><!-- 
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
        href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,400;0,600;0,700;0,800;1,400;1,700&display=block"
        rel="stylesheet"
    />
    <link
        href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,400;0,700;0,800;1,400&display=swap"
        rel="stylesheet"
    />
--><link rel="preload" href="/fonts/open-sans-v34-latin-regular.woff2" as="font" type="font/woff2" crossorigin="crossorigin"><link rel="preload" href="/fonts/open-sans-v34-latin-700.woff2" as="font" type="font/woff2" crossorigin="crossorigin"><link rel="preload" href="/fonts/open-sans-v34-latin-800.woff2" as="font" type="font/woff2" crossorigin="crossorigin"><link rel="preload" href="/fonts/open-sans-v34-latin-italic.woff2" as="font" type="font/woff2" crossorigin="crossorigin"><style>
    /* open-sans-regular - latin */
    @font-face {
      font-family: "Open Sans";
      font-style: normal;
      font-weight: 400;
      font-display: fallback;
      src: local(""),
        url("/fonts/open-sans-v34-latin-regular.woff2") format("woff2"),
        /* Chrome 26+, Opera 23+, Firefox 39+ */
          url("/fonts/open-sans-v34-latin-regular.woff") format("woff"); /* Chrome 6+, Firefox 3.6+, IE 9+, Safari 5.1+ */
    }
    /* open-sans-700 - latin */
    @font-face {
      font-family: "Open Sans";
      font-style: normal;
      font-weight: 700;
      font-display: fallback;
      src: local(""),
        url("/fonts/open-sans-v34-latin-700.woff2") format("woff2"),
        /* Chrome 26+, Opera 23+, Firefox 39+ */
          url("/fonts/open-sans-v34-latin-700.woff") format("woff"); /* Chrome 6+, Firefox 3.6+, IE 9+, Safari 5.1+ */
    }
    /* open-sans-800 - latin */
    @font-face {
      font-family: "Open Sans";
      font-style: normal;
      font-weight: 800;
      font-display: fallback;
      src: local(""),
        url("/fonts/open-sans-v34-latin-800.woff2") format("woff2"),
        /* Chrome 26+, Opera 23+, Firefox 39+ */
          url("/fonts/open-sans-v34-latin-800.woff") format("woff"); /* Chrome 6+, Firefox 3.6+, IE 9+, Safari 5.1+ */
    }
    /* open-sans-italic - latin */
    @font-face {
      font-family: "Open Sans";
      font-style: italic;
      font-weight: 400;
      font-display: fallback;
      src: local(""),
        url("/fonts/open-sans-v34-latin-italic.woff2") format("woff2"),
        /* Chrome 26+, Opera 23+, Firefox 39+ */
          url("/fonts/open-sans-v34-latin-italic.woff") format("woff"); /* Chrome 6+, Firefox 3.6+, IE 9+, Safari 5.1+ */
    }
  </style>

    <script>
  // figure out user's preferred theme and set it as html class for tailwind before paint
  (function () {
    if (typeof window !== "undefined") {
      const isSystemColorSchemeDark = window.matchMedia(
        "(prefers-color-scheme: dark)"
      ).matches;
      const storageTheme = sessionStorage.getItem("theme");
      if (!storageTheme && isSystemColorSchemeDark) {
        document.documentElement.classList.add("dark");
        document.head.children.namedItem("theme-color").content = "#0e141b";
      } else if (storageTheme === "dark") {
        document.documentElement.classList.add("dark");
        document.head.children.namedItem("theme-color").content = "#0e141b";
      } else {
        // we already server render light theme
        document.head.children.namedItem("theme-color").content = "#ffffff";
      }
    }
  })();
</script>

    <link href="/fontawesome/css/fontawesome.bareminimum.css" rel="stylesheet"><link href="/fontawesome/css/brands.bareminimum.css" rel="stylesheet"><link href="/fontawesome/css/solid.min.css" rel="stylesheet">

  <link rel="stylesheet" href="/assets/_...slug_.eb89f7da.css" />
<link rel="stylesheet" href="/assets/_...slug_.43380762.css" /><script type="module" src="/hoisted.fee86805.js"></script></head>

  <body class="min-h-screen max-w-3xl mx-auto px-6 sm:px-8 astro-RDWXBD3Z">
    <header class="astro-ZCCACUUV">
  <a class="unset absolute z-10 left-[50%] -top-[100rem] translate-x-[-50%] bg-white text-black px-8 py-2 focus:top-[initial] astro-ZCCACUUV" href="#main">
    Skip to content
  </a>
  <nav class="astro-ZCCACUUV">
    <section class="text-text-bold astro-ZCCACUUV">
      <ul class="unset flex gap-4 [&>li]:p-0 astro-ZCCACUUV">
        <li class="astro-ZCCACUUV"><!-- DO NOT FORMAT. IT ADDS AN EXTRA SPACE ON RENDERED CONTENT. --><a href="/" class="astro-ZCCACUUV unset animated-link">Home</a></li>
        <li class="astro-ZCCACUUV"><!-- DO NOT FORMAT. IT ADDS AN EXTRA SPACE ON RENDERED CONTENT. --><a href="/blog" class="astro-ZCCACUUV show unset animated-link">Blog</a></li>
      </ul>
    </section>
  </nav>
  <div class="max-[375px]:hidden justify-self-end py-2 flex items-center content-center text-text-bold astro-ZCCACUUV">
    <a class="unset text-xl ml-4 hover:text-text-link astro-ZCCACUUV" href="https://github.com/yeonjuan" target="_blank">
      <i class="fa-brands fa-github astro-ZCCACUUV" aria-hidden="true" title="Blogster on GitHub"></i>
      <span class="fa-sr-only astro-ZCCACUUV">YeonJuAn GitHub</span>
    </a>
  </div>
  <mode-toggle class="flex astro-2DKTDEXU">
  <button class="justify-self-end bg-neutral-200 dark:bg-neutral-700 ml-4 inline-flex h-6 w-11 items-center rounded-full astro-2DKTDEXU" id="mode-toggle" role="switch" type="button" tabindex="0" aria-checked="false" data-headlessui-state=""><span class="sr-only astro-2DKTDEXU">Toggle dark mode</span><span id="mode-circle" class="light inline-block h-4 w-4 rounded-full bg-gradient-to-tr invisible astro-2DKTDEXU"><span class="absolute top-0 right-0 w-[10px] h-[10px] rounded-full bg-gray-700 scale-[0] astro-2DKTDEXU"></span>
  </span>
</button>
</mode-toggle>




</header>

    <main id="main" class="astro-RDWXBD3Z">
      <section class="blog-post prose max-w-none prose-sleek astro-RDWXBD3Z">
        <time class="block mb-[2em] text-text-muted astro-RDWXBD3Z">Oct 29, 2023</time>
        <article><h1 id="(barrel)" class="group flex -ml-[1rem]"><span class="not-prose w-[1rem] -mt-[0.125rem]">
        <a aria-label="link to this heading" aria-describedby="자바스크립트 에코시스템의 속도 향상 - 배럴(Barrel) 파일의 대실패" href="#(barrel)" class="unset align-middle text-[14px] text-text-link opacity-0 group-hover:opacity-100 group-focus:opacity-100 focus:opacity-100 group-active:opacity-100 active:opacity-100">
            <i class="fa-solid fa-hashtag"></i>
        </a>
    </span><span>자바스크립트 에코시스템의 속도 향상 - 배럴(Barrel) 파일의 대실패</span></h1><blockquote><paragraph>원문: https://marvinh.dev/blog/speeding-up-javascript-ecosystem-part-7/</paragraph></blockquote><blockquote><paragraph>요약: 많은 프로젝트에 다른 파일을 다시 export하는 파일들로 가득 차 있습니다. 소위 &quot;배럴(Barrel) 파일&quot;이라고 불리는 이런 파일은 대규모 프로젝트에서 자바스크립트 툴이 느려지는 주요 원인 중 하나입니다.</paragraph></blockquote><ul><li><a href="https://marvinh.dev/blog/speeding-up-javascript-ecosystem/">파트 1: PostCSS, SVGO 등</a></li><li><a href="https://marvinh.dev/blog/speeding-up-javascript-ecosystem-part-2/">파트 2: 모듈 해석(resolution)</a></li><li><a href="https://marvinh.dev/blog/speeding-up-javascript-ecosystem-part-3/">파트 3: eslint를 사용한 린팅</a></li><li><a href="https://marvinh.dev/blog/speeding-up-javascript-ecosystem-part-4/">파트 4: npm scripts</a></li><li><a href="https://marvinh.dev/blog/speeding-up-javascript-ecosystem-part-5/">파트 5: draft-js 이모지 플러그인</a></li><li><a href="https://marvinh.dev/blog/speeding-up-javascript-ecosystem-part-6/">파트 6: 불량해진 폴리필</a></li><li><a href="#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%97%90%EC%BD%94%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EC%86%8D%EB%8F%84-%ED%96%A5%EC%83%81---%EB%B0%B0%EB%9F%B4barrel-%ED%8C%8C%EC%9D%BC%EC%9D%98-%EB%8C%80%EC%8B%A4%ED%8C%A8">파트 7: 배럴(Barrel) 파일의 대실패</a></li></ul><paragraph>수많은 파일이 있는 대규모 프로젝트에서 작업을 한다고 가정해 봅시다. 여러분은 새로운 기능을 작업하기 위해 파일을 추가하고 함수를 다른 디렉터리에서 가져왔습니다.</paragraph><pre class="language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> foo <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"./some/other-file"</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">myCoolCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 아주 똑똑한 코드라고 가정합니다. :)</span>
  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>

<paragraph>기능을 완성할 생각에 들떠 코드를 실행해 보니, 완료되기까지 시간이 너무 오래 걸린다는 걸 알게 되었습니다. 여러분이 작성한 코드는 매우 간단하기에 시간이 많이 걸리지 않아야 합니다. 이 점이 염려되어, 함수가 작업을 수행하는 데 걸리는 시간을 확인하기 위한 측정 코드를 추가했습니다.</paragraph><pre class="language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> foo <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"./some/other-file"</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">myCoolCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>

<paragraph>코드를 다시 실행하면 측정된 값은 매우 짧은 시간으로 나옵니다. 혹시 몰라 이번에는 프로젝트의 메인 진입점 파일에 <code>console.time()</code>문을 추가하고 다시 실행해보겠습니다. 말짱 도루묵입니다. 기록된 측정값은 코드 자체가 매우 빠르다는 것만 확인시켜줄 뿐입니다. 무슨 일이 일어난 걸까요?</paragraph><paragraph>자, 이제 배럴 파일이 코드에 미치는 치명적인 영향에 대한 이야기를 시작해보겠습니다.</paragraph><h2 id="" class="group flex -ml-[1rem]"><span class="not-prose w-[1rem] -mt-[0.125rem]">
        <a aria-label="link to this heading" aria-describedby="자세한 정보 수집" href="#" class="unset align-middle text-[14px] text-text-link opacity-0 group-hover:opacity-100 group-focus:opacity-100 focus:opacity-100 group-active:opacity-100 active:opacity-100">
            <i class="fa-solid fa-hashtag"></i>
        </a>
    </span><span>자세한 정보 수집</span></h2><paragraph>지금까지 얻은 핵심 정보는 코드의 런타임이 문제가 아니라는 것입니다. 런타임은 전체 시간의 극히 일부에 불과했습니다. 즉, 코드를 실행하기 <em>전</em>이나 <em>후</em>에 시간이 낭비된다고 가정할 수 있습니다. 경험에 비추어 볼 때, 도구에 소요되는 시간은 프로젝트 코드를 실행하기 전에 소비됩니다.</paragraph><paragraph>일부 npm 패키지는 성능상의 이유로 코드를 미리 번들링 한다는 이야기를 들으셨을 겁니다. 이 방법이 도움이 될 수 있을까요? 이 이론을 테스트하기 위해 <a href="https://esbuild.github.io/">esbuild</a>를 사용해 코드를 단일 파일로 번들링하기로 결정했습니다. 원본 소스와 가장 비슷하게 코드를 유지하기 위해서 어떤 형태의 최소화(minification)를 의도적으로 비활성화합니다.</paragraph><paragraph>번들링을 마치고 해당 파일로 다시 실험해보면 눈 깜짝할 사이에 완료가 됩니다. 호기심에 esbuild를 실행하고 번들 파일을 함께 실행하는 데 걸리는 시간을 측정해 보니 둘을 합친 시간이 원본 소스 코드를 실행하는 것보다 여전히 빠르다는 것을 알 수 있습니다. 그렇죠? 무슨 일이 벌어지고 있는 걸까요?</paragraph><paragraph>번들러가 주로 하는 일은 모듈 그래프를 평평하게 만들고 병합하는 것이라는 사실이 문뜩 떠오릅니다. 수천 개의 파일로 구성되어 있던 모듈 그래프가 esbuild를 통해 단일 파일로 병합되었습니다. 이는 모듈 그래프의 크기가 진짜 문제라는 강력한 지표가 될 수 있습니다. 그리고 배럴 파일이 그 주요 원인입니다.</paragraph><h2 id="" class="group flex -ml-[1rem]"><span class="not-prose w-[1rem] -mt-[0.125rem]">
        <a aria-label="link to this heading" aria-describedby="배럴 파일 해부" href="#" class="unset align-middle text-[14px] text-text-link opacity-0 group-hover:opacity-100 group-focus:opacity-100 focus:opacity-100 group-active:opacity-100 active:opacity-100">
            <i class="fa-solid fa-hashtag"></i>
        </a>
    </span><span>배럴 파일 해부</span></h2><paragraph>배럴 파일은 다른 파일만 내보내고 코드 자체는 포함하지 않는 파일입니다. 원어민이 아닌 저로서는 이 용어가 혼란스럽지만 그냥 넘어가겠습니다. 에디터에 자동 import 같은 편의 기능이 없던 시절에는 많은 개발자가 직접 작성해야 하는 import 문의 수를 최소화하려고 노력했습니다.</paragraph><pre class="language-js"><code class="language-js"><span class="token comment">// 이 import 문을 보세요.</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> foo <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"../foo"</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> bar <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"../bar"</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> baz <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"../baz"</span><span class="token punctuation">;</span>
</code></pre>

<paragraph>이로 인해 모든 폴더에 일반적으로 같은 디렉터리에 있는 다른 파일에서 코드를 다시 export하는 자체 <code>index.js</code> 파일이 생기는 패턴이 생겼습니다. 이러한 파일이 있으면 다른 모든 코드가 하나의 import 문만 참조하면 되기 때문에 수동 입력 작업이 줄어드는 효과가 있었습니다.</paragraph><pre class="language-js"><code class="language-js"><span class="token comment">// feature/index.js</span>
<span class="token keyword">export</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token string">"./foo"</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token string">"./bar"</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token string">"./baz"</span><span class="token punctuation">;</span>
</code></pre>

<paragraph>이제 이전에 표시된 import 문을 한 줄로 축소할 수 있습니다.</paragraph><pre class="language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> foo<span class="token punctuation">,</span> bar<span class="token punctuation">,</span> baz <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"../feature"</span><span class="token punctuation">;</span>
</code></pre>

<paragraph>시간이 지나면 이 패턴이 코드 베이스 전체에 퍼지고 프로젝트의 모든 폴더에 <code>index.js</code> 파일이 생깁니다. 꽤 멋지지 않나요? 글쎄요.</paragraph><h2 id="." class="group flex -ml-[1rem]"><span class="not-prose w-[1rem] -mt-[0.125rem]">
        <a aria-label="link to this heading" aria-describedby="전부 괜찮지 않습니다." href="#." class="unset align-middle text-[14px] text-text-link opacity-0 group-hover:opacity-100 group-focus:opacity-100 focus:opacity-100 group-active:opacity-100 active:opacity-100">
            <i class="fa-solid fa-hashtag"></i>
        </a>
    </span><span>전부 괜찮지 않습니다.</span></h2><paragraph>이런 셋업에서 모듈은 다른 파일을 import 하는 또 다른 배럴 파일을 import 하고, 이 배럴 파일은 또 다른 배럴 파일을 가져오는 식으로 import할 가능성이 높습니다. 결국에는 거미줄처럼 얽힌 import 문을 통해 프로젝트의 모든 파일을 import 하게 됩니다. 그리고 프로젝트가 클수록 이런 모든 모듈을 로드하는 데 시간이 더 오래 걸립니다.</paragraph><paragraph>자문해 보세요. 무엇이 더 빠를까요? 3만 개의 파일을 로드하기? 아니면 10개? 아마도 10개의 파일만 로드하는 것이 더 빠를 것입니다.</paragraph><paragraph>모듈이 필요할 때만 로드된다는 것은 자바스크립트 개발자들 사이에서 흔히 발생하는 오해입니다. 이는 사실이 아닙니다. 왜냐하면 그렇게 하면 전역이나 모듈 실행 순서에 의존하는 코드가 손상될 수 있습니다.</paragraph><pre class="language-js"><code class="language-js"><span class="token comment">// a.js</span>
globalThis<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>

<span class="token comment">// b.js</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>globalThis<span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 123 이 로깅되어야 함</span>

<span class="token comment">// index.js</span>
<span class="token keyword">import</span> <span class="token string">"./a"</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string">"./b"</span><span class="token punctuation">;</span>
</code></pre>

<paragraph>엔진이 첫 번째 <code>./a</code> import를 로드하지 않으면, 코드는 예기치 않게 <code>123</code> 대신 <code>undefined</code>가 기록됩니다.</paragraph><h2 id="" class="group flex -ml-[1rem]"><span class="not-prose w-[1rem] -mt-[0.125rem]">
        <a aria-label="link to this heading" aria-describedby="배럴 파일이 성능에 미치는 영향" href="#" class="unset align-middle text-[14px] text-text-link opacity-0 group-hover:opacity-100 group-focus:opacity-100 focus:opacity-100 group-active:opacity-100 active:opacity-100">
            <i class="fa-solid fa-hashtag"></i>
        </a>
    </span><span>배럴 파일이 성능에 미치는 영향</span></h2><paragraph>테스트 러너와 같은 도구를 고려하면 상황은 더욱 심각해집니다. 널리 사용되는 jest 테스트 러너에서 각 테스트 파일은 고유한 자식 프로세스에서 실행됩니다. 이는 사실상 모든 테스트 파일이 모듈 그래프를 처음부터 다시 구성하고 그에 대한 비용을 지불해야 한다는 것을 뜻합니다. 프로젝트에서 모듈 그래프를 구성하는 데 6초가 걸리고 테스트 파일이 100개만 있다고 가정하면 모듈 그래프를 반복적으로 구성하는 데 총 10분을 낭비하는 것입니다. 그 시간 동안 테스트나 다른 코드는 실행되지 않습니다. 엔진이 소스 코드를 준비해서 실행할 수 있도록 하는 데 필요한 시간일 뿐입니다.</paragraph><paragraph>배럴 파일이 성능에 심각한 영향을 미치는 또 다른 영역은 모든 종류의 import 사이클 린트 규칙입니다. 일반적으로 린터는 파일 단위로 실행되므로 모듈 그래프를 구성하는 데 드는 비용을 모든 파일에 지불해야 합니다. 이로 인해 린팅 시간이 통제 불능 상태가 되어 대규모 프로젝트에서 갑자기 린팅에 몇 시간이 걸리는 경우가 종종 있습니다.</paragraph><paragraph>원시적인 수치를 얻고 모듈 그래프를 구성하는 데 드는 비용을 더 잘 파악하기 위해 파일을 서로 import 하는 프로젝트를 생성했습니다. 모든 파일은 비어 있으며 import 문 이외의 코드는 포함하지 않습니다. 시간은 제 MacBook M1 Air (2020)에서 측정했습니다.</paragraph><paragraph><image alt="" src="https://marvinh.dev/media/js-tools-module-cost.png"></image></paragraph><paragraph>보시다시피 모듈을 더 적게 로드하면 그만한 가치가 있습니다. 이러한 숫자를 100개의 테스트 파일이 있는 프로젝트에 적용하고, 각 테스트 파일에 새로운 자식 프로세스를 생성하는 테스트 실행 도구를 사용한다고 가정해 봅시다. 여기서는 테스드 러너가 4개의 테스트를 병렬로 실행할 수 있다고 가정해 보겠습니다.</paragraph><ul><li>모듈 500 개: <code>0.15s \* 100 / 4</code> = <code>3.75s</code> 오버헤드</li><li>모듈 1000 개: <code>0.31s \* 100 / 4</code> = <code>7.75s</code> 오버헤드</li><li>모듈 10000 개: <code>3.12s \* 100 / 4</code> = <code>1:18m</code> 오버헤드</li><li>모듈 25000 개: <code>16.81s \* 100 / 4</code> = <code>~7:00m</code> 오버헤드</li><li>모듈 50000 개: <code>48.44s \* 100 / 4</code> = <code>~20:00m</code> 오버헤드</li></ul><paragraph>이것은 인위적인 설정이므로, 낮게 잡힌 수치입니다. 실제 프로젝트에서는 이 수치가 더 나빠질 가능성이 높습니다. 배럴 파일은 툴링 성능 측면에서 좋지 않습니다.</paragraph><h2 id="" class="group flex -ml-[1rem]"><span class="not-prose w-[1rem] -mt-[0.125rem]">
        <a aria-label="link to this heading" aria-describedby="해야 할 일" href="#" class="unset align-middle text-[14px] text-text-link opacity-0 group-hover:opacity-100 group-focus:opacity-100 focus:opacity-100 group-active:opacity-100 active:opacity-100">
            <i class="fa-solid fa-hashtag"></i>
        </a>
    </span><span>해야 할 일</span></h2><paragraph>코드에 배럴 파일이 몇 개만 있는 것은 보통 괜찮지만, 모든 폴더에 배럴 파일이 있으면 문제가 됩니다. 안타깝게도 자바스크립트 업계에서는 이런 일이 드물지 않게 발생합니다.</paragraph><paragraph>따라서 배럴 파일을 광범위하게 사용하는 프로젝트에서 작업하는 경우, 많은 작업을 60~80% 더 빠르게 만드는 무료 최적화를 적용할 수 있습니다.</paragraph><paragraph>모든 배럴 파일을 제거하세요.</paragraph></article>
      </section>
    </main>
    <footer class="text-sm leading-[1.75] mt-4 astro-IKVAUYX3">
  <div class="astro-IKVAUYX3">
    This blog is built with
    <a class="unset gradient-link tracking-wider font-bold bg-clip-text text-transparent bg-gradient-to-r from-[#f57111] to-[#f79605] hover:after:bg-gradient-to-r hover:after:from-[#f57111] hover:after:to-[#f79605] astro-IKVAUYX3" href="https://github.com/flexdinesh/blogster" target="_blank">
      Blogster</a>
  </div>
</footer>


    
  </body>
</html>